<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F12%2FJavaScript%E5%80%BC%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[jquery选择器]]></title>
    <url>%2F2019%2F06%2F10%2Fjquery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.基本选择器基本选择器是Jquery中最常用的选择器 id选择器: $(“#id”) 选择id值为 element 的元素,id值在文档中不能重复,所以的到的是唯一的元素 元素选择器: $(“div”) 选择所有的div标签,返回 div 元素数组 类选择器: $(“.class”) 选择使用 class 类的所有元素 $(“*”) 选中文档中的所有元素 2.层叠选择器如果想通过 DOM 元素之间的 层次关系来获取特定元素,如:后代元素,子元素,相邻元素,兄弟元素等.则需要使用层次选择器 后代选择器: $(“form input”) 选择所有 form 元素中的input元素,包含子元素 儿子选择器: $(“form &gt; input”) 选择所有的form元素中的 input 元素,只包含子元素,不包含子元素的子元素 相邻元素选择器: $(“label + input”) 选择label元素的下一个input元素节点 兄弟选择器: $(“#perv ~ div”) 选择id为 prev 的标签元素的所有的属于同一个父元素的div标签 3.过滤选择器可以通过特定的规则筛选出所需的DOM元素,一般以 “:” 开头按照不同的过滤规则,可分为:内容过滤,可见性过滤,属性过滤,子元素过滤,表单对象属性过滤选择器 3.1基础过滤选择器 $(“tr:first”):选择所有 tr 元素的第一个 (“tr:last”):选择所有tr元素的最后一个 $(“tr:even”):选择索引号为偶数的tr元素 索引从 0 开始 $(“tr:odd”) 选择所有的 tr 元素的 索引号为奇数 3.2内容过滤器 $(“div:contains(‘jn’)”):选择所有div 中含有 jn 文本的元素 $(“td:empty”)选择所有为空的 td 元素 $(“div:has(p)”)选择所有含有 p 标签的div 元素 $(“td:parent”)选择所有以td为父节点的元素数组 3.3可视化过滤器 $(“div:hidden”)选择所有的被hidden的div元素 $(“div:visible”)选择所有的可视化的div元素 3.4属性选择过滤器 $(“div[id]”) 选择所有含 id 属性的div元素 $(“input[name=’news’]”)选择所的name 属性等于 news 的 input 元素 $(“input[name^=’news’]”)选择所有的name属性以’news’开头的input元素 $(“input[name$=’news’]”)选择所有的name属性以news结尾的 input 元素 $(“input[name*=’news’]”)选择包含’news’的input元素 3.5子元素过滤器 $(“ul li:nth-child(n)”)匹配其父元素下的第 n 个元素 odd奇数 even偶数 $(“div span:first-child”)返回所有的div元素的第一个子节点的数组 $(“div span:last-child”)返回所有的div元素的最后一个节点]]></content>
      <categories>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>-jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基本指令]]></title>
    <url>%2F2019%2F06%2F10%2Fvue%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Vue.jsVue.js基础 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；1234567891011121314151617181920212223242526272829303132333435const http = require('http');// 导入解析 URL 地址的核心模块const urlModule = require('url');const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on('request', (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end('404'); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log('server running at http://127.0.0.1:3000');&#125;); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构： 1234567&lt;div id="app"&gt; &lt;input type="button" value="动起来" @click="myAnimate"&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name="fade"&gt; &lt;div v-show="isshow"&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例： 123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;); 定义两组类样式： 12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库： 1&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt; 定义 transition 及属性： 123456&lt;transition enter-active-class="fadeInRight" leave-active-class="fadeOutRight" :duration="&#123; enter: 500, leave: 800 &#125;"&gt; &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数： 123456789&lt;div id="app"&gt; &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法： 12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = 'translateX(500px)'; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = 'translateX(0px)'; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125; 定义动画过渡时长和样式： 123.show&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式： 123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： 1234567&lt;div id="app"&gt; &lt;input type="text" v-model="txt" @keyup.enter="add"&gt; &lt;transition-group tag="ul" name="list"&gt; &lt;li v-for="(item, i) in list" :key="i"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM中的结构： 1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; txt: '', list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = ''; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器]]></content>
      <categories>
        <category>Vue.js相关</category>
      </categories>
      <tags>
        <tag>-vue</tag>
      </tags>
  </entry>
</search>
