<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6解构赋值]]></title>
    <url>%2F2019%2F06%2F22%2FES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[数组的解构赋值、基本用法 以前变量赋值的写法，只能直接指定值 12let a = 1;let b = 2; ES6写法 1let[a,b] = [1,2] 本质上是模式匹配，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 123456let [x,,y] = [1,2,3]x //13 //3let [head,...tail] = [1,2,3,4]head //1tail //[2,3,4] 若解构不成功，变量的值就等于undefined 1let [foo] = [] //解构失败 不完全解构123let [x,y] = [1,2,3]x //1y //2 默认值 解构赋值允许指定默认值 12345678let[foo = true] = [];foo //truelet [x,y = 'b'] = ['a']//x = 'a',y ='b'let [x,y = 'b'] = ['a','c']//x = 'a',y = 'c' 只有当一个数组成员严格等于(===)undefined,默认值才会生效 12let [x,y = 'b'] = ['a',undefined]//x = 'a',y = 'b' 对象的解构赋值 对象的解构，属性没有次序，变量必须与属性名同名才能取到正确值 123let &#123; bar,foo &#125; = &#123; foo:'aaa',bar:'bbb' &#125;;foo //'aaa'bar //'bbb' 若变量名和属性名不一致，必须写成以下这种形式12let &#123; foo:baz &#125; = &#123; foo:'aaa',bar:'bbb' &#125;;baz //"aaa",真正赋值的是赋值给baz,foo只是指定匹配模式 对象的解构赋值是下面形式的间写 1let &#123;foo:foo,bar:bar&#125; = &#123; foo:'aaa',bar:'bbb' &#125; 对象解构的内部机制：是先找到同名属性，然后再赋给对应的变量，真正被赋值的是后者，而不是前者。123let &#123; foo:baz &#125; = &#123; foo:'aaa',bar:'bbb'&#125;baz //"aaa"foo //报错 foo 只是匹配模式，baz才是变量。真正被赋值的是变量的baz,而不是模式 foo 嵌套结构赋值123456789let obj = &#123; p:[ 'hello', &#123; y:'world' &#125; ]&#125;;let &#123; p:[x,&#123; y &#125;] &#125; = obj；x // 'hello'y // 'world' 字符串的解构赋值 字符串被转换成了一个类似数组的对象const [a,b,c,d,e] = ‘hello’;a //“h”b //“e” 数值和布尔值的解构赋值 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象 函数参数的解构赋值12345function add([x,y])&#123; return x + y;&#125;add([1,2]) // 3 圆括号问题用途变换变量的值123let x = 1;let y = 2;[x,y] = [y,x]; 从函数中返回多个值12345678910111213//返回一个数组function example1()&#123; return [1,2,3];&#125;let [a,b,c] = example1();//返回一个对象function example2()&#123; return &#123; foo:1, bar:2 &#125;;&#125;let &#123; foo,bar &#125; = example2(); 函数参数的定义解构赋值可以方便的将一组数组与变量名联系对应起来 1234567//参数是一组有次序的值function f([x,y,z])&#123;...&#125;f([1,2,3]);/参数是一组无次序的值function f(&#123;x,y,z&#125;)&#123;..&#125;f(&#123;z:3,y:2,x:1&#125;); 提取JSON数据1234567let jsonData = &#123; id：42， status:'OK', data:[867,5309]&#125;;let &#123;id,status,data:number&#125; = jsonData;console.log(id,status,number); //42,"OK",[867,5309] 函数参数的默认值未完待续…..]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6-let和const]]></title>
    <url>%2F2019%2F06%2F22%2FES6-let%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[let和constlet基本用法1234&#123; let a = 10; var b = 1;&#125; let 声明变量是只在它所在的代码块有效，变量不提升 var 声明变量会提升 for循环技术器12345678//letfor( let i = 0；i &lt; 10;i++ )&#123; a[i] = function()&#123; console.log(i); &#125;;&#125;console.log(i)//在循环体外引用就会报错a[6]() //6 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是 6。 JavaScript引擎内部会记住上一轮循环的值,初始化本轮的变量i，就在上一轮的基础上进行计算 1234567//varfor( var i = 0; i &lt; 10;i++ )&#123; a[i] = function()&#123; console.log(i); &#125;;&#125;a[6]() // 10 变量i是var命令声明的，在全局范围内都有效，所以都是在操作同一个i;每一次啊循环，变量i的值都会发生改变 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响；总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上称为暂时性死区 注意：ES6规定暂时性死区和let,const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前使用这个变量 小结：暂时性死区的本质就是，只要一进入到当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量 不允许重复声明 let 不允许在相同作用域内，重复声明同一个变量 块级作用域为什么需要块级作用域？ES5中只有全局作用域和函数作用域，没有块级作用域，会带来许多不合理的场景 第一种场景，内层变量可能会覆盖外层变量 123456789var tmp = new Date();function f()&#123; console.log(tmp);//此时变量提升，所有 tmp 为 undefined if(false)&#123; &lt;!-- 此时变量tmp提升 覆盖全局的tmp--&gt; var tmp = "hello world"; &#125;&#125;f();//undefined 第二种场景,用来计数的循环变量泄露为全局变量 12345var s = 'hello'for( var i = 0;i &lt; s.length;i++ )&#123; console.log(s[i]);&#125;console.log(i)//5 此时的 i 在循环结束并没有消失，泄露成了全局变量 ES6块级作用域 ES6新增块级作用域，而不需要像ES5那样使用立即执行函数表达式包裹而成的 块级作用域内，优先使用函数表达式来声明函数 const命令 const 声明一个只读变量，一旦声明，常量的值就不能改变； 同let一样，只在声明所在的块级作用域内有效，声明的常量也是不提升的，同样存在暂时性死区 const本质 const实际保证的，并不是变量的值不得变动，而是变量指向的那个内存地址所保存的数据不的变动 基本类型对于基本数据类型来说，变量就保存值值 复杂类型对于复杂数据类型来说，变量指向的是内存地址，保存的只是一个指针。const只能保证这个指针是固定的(即总是指向一个固定地址)至于它指向的数据结构是不是可变的，就完全不能控制了。 12345const foo = &#123;&#125;;foo.prop =123;foo.prop //123,是可以对象添加属性foo = &#123;&#125;; //此时改变了 foo 的指向，则报错了 若向冻结对象,可使用 object.freeze()方法 ES6声明变量的六种方法 ES5中只有两种变量的方法：var命令和function命令；ES6添加了 let和const命令。还有 import和class 顶层对象的属性在浏览器中，顶层对象是window对象；在node中，指的是global对象；在ES5中，顶层对象和全局变量是等价的ES6规定，let，const，class声明的全局变量，不属于顶层对象。而var和function命令声明的全局变量依旧是顶层对象的属性 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined globalThis对象 javascript语言存在一个顶层对象，它提供全局环境(即全局作用域)，所有代码都是在这个环境中运行。 在浏览器中，顶层对象是window,但 node和web worker 没有 window 浏览器和web worker 里面的，self也指向顶层对象，但是 node 没有 self noee中，顶层对象是global,但其他环境都不支持 一般使用this变量取得顶层对象 全局环境，this返回顶层对象;在node模块和ES6模块中，this返回的是当前模块 函数里面的this,如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined 参考数据ECMAScript 6入门]]></content>
      <categories>
        <category>javascript相关</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对vue中插槽(slot)的理解]]></title>
    <url>%2F2019%2F06%2F13%2F%E5%AF%B9vue%E4%B8%AD%E6%8F%92%E6%A7%BD-slot-%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[插槽 官方文档解释 Vue实现了一套内容分发的API,这套API的设计灵感源自 Web Components 规范草,将&lt;slot&gt;元素作为承载分发内容的出口 简单的概念理解:插槽,也就是slot,是组件的一块HTMl的模板,这块模板,显示和不显示,以及怎样显示都是由父组件决定的.官方文档不是特别好理解,按我个人理解就是,&lt;slot&gt;在子组件相当于一个占位符,留出位置,方便我们插入内容,而内容分发其实就是将父组件的内容放到子组件指定的位置 模板的分类 对于任何一个组件而言,从模板种类的角度来分,都可以分成两大类,非插槽模板和插槽模板 非插槽模板非插槽模板指的是 html 模板,如 ‘div,span,ul,table’,非插槽模板的显示和隐藏以及怎样显示都是由自身组件控制 插槽模板插槽模板是slot,它是一个空的占位盒子,因为它的显示和隐藏以及最后用什么样的html模板显示都是由父组件控制的.但是插槽显示的位置却是由子组件自身决定的,slot写在子组件 template 的什么位置,父组件传过来的的模板就是在什么位置 插槽的分类1. 匿名插槽(单个插槽或默认插槽) 特点: 无name属性 在组件中只可以使用一次 父组件提供样式和内容 单个插槽也交匿名插槽,可以放在组件的任意位置,一个组件只能设置一个.而具名插槽可以设置很多个,只要名字(name属性)不同就可以 例子: 父组件: 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;h2&gt;这里是父组件&lt;/h2&gt; &lt;/div&gt; &lt;son&gt; &lt;div class="temp"&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单3&lt;/span&gt; &lt;/div&gt; &lt;/son&gt;&lt;/template&gt;&lt;script&gt; import son from '@/components/child' export default &#123; components:&#123; 'son':son &#125; &#125;&lt;/script&gt;&lt;style&gt;.temp span&#123; width: 100px; height: 100px; background-color: red;&#125;&lt;/style&gt; 子组件son: 123456&lt;template&gt; &lt;div class="son&gt;"&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 在上述例子中,因为父组件在里面写了html模板,那么子组件的匿名插槽就被使用了,是被下面这块模板使用的: 12345&lt;div class="temp"&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单3&lt;/span&gt;&lt;/div&gt; 即此时,子组件slot 中此时是插入的内容就是上面父组件中的传递过去的模板2. 具名插槽 特点: 有name属性 在组件中可以使用N次 父组件通过 html 模板上的slot属性关联具名插槽 没有slot属性的html模板默认关联匿名模板 父组件提供样式和内容例子:父组件:1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class="father"&gt; &lt;h2&gt;这里是父组件&lt;/h2&gt; &lt;son&gt; &lt;div class="temp1" slot="up"&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单3&lt;/span&gt; &lt;/div&gt; &lt;div class="temp2" slot="down"&gt; &lt;span&gt;菜单3&lt;/span&gt; &lt;span&gt;菜单2&lt;/span&gt; &lt;span&gt;菜单1&lt;/span&gt; &lt;/div&gt; &lt;/son&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Child from '@/components/child' export default &#123; components:&#123; child:child &#125; &#125;&lt;/script&gt;&lt;style&gt;/*插槽的样式由父组件设置*/.temp1&#123; width:100px; height:100px; background-color:red;&#125;.temp1&#123; width:100px; height:100px; background-color:yellow;&#125;&lt;/style&gt; 子组件: 1234567&lt;template&gt; &lt;slot name="up"&gt;&lt;/slot&gt; &lt;div&gt; &lt;h3&gt;这是子组件&lt;/h3&gt; &lt;/div&gt; &lt;slot name="down"&gt;&lt;/slot&gt;&lt;/template&gt; 父组件通过 slot 属性定义具名插槽,子组件的slot通过 name 属性,在指定位置插入内容 3. 作用域插槽(带数据的插槽) 特点: 父组件只提供样式,子组件提供内容 在slot上面绑定数据 子组件的值可以传给父组件使用 父组件展示子组件数据有三种方式:flex显示,ul显示,直接显示 使用slot-scope必须使用template scope返回的值是slot标签上返回的所有属性值,并且以一个对象形式保存起来 slot有两个属性,一个 row,另一个是index父组件: 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class="father"&gt; &lt;h3&gt;这里是父组件&lt;/h3&gt; &lt;!--第一次使用：用flex展示数据--&gt; &lt;child&gt; &lt;template slot-scope="user"&gt; &lt;div class="tmpl"&gt; &lt;span v-for="item in user.data"&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/child&gt; &lt;!--第二次使用：用列表展示数据--&gt; &lt;child&gt; &lt;template slot-scope="user"&gt; &lt;ul&gt; &lt;li v-for="item in user.data"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/child&gt; &lt;!--第三次使用：直接显示数据--&gt; &lt;child&gt; &lt;template slot-scope="user"&gt; &#123;&#123;user.data&#125;&#125; &lt;/template&gt; &lt;/child&gt; &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt; &lt;child&gt; 我就是模板 &lt;/child&gt; &lt;/div&gt;&lt;/template&gt; 子组件: 12345678910111213141516&lt;template&gt; &lt;div class="child"&gt; &lt;h3&gt;这里是子组件&lt;/h3&gt; // 作用域插槽 &lt;slot :data="data"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; export default &#123; data: function()&#123; return &#123; data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba'] &#125; &#125; &#125; 小结:作用域插槽跟单个插槽和具名插槽的区别,因为单个插槽和具名插槽不绑定数据所以父组件提供的模版既要包括样式,又包括内容.而作用域插槽,父组件只需要提供一套样式 作用域编译 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git版本管理]]></title>
    <url>%2F2019%2F06%2F13%2Fgit%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[版本回退 在git中,每当你觉得把文件修改到一定程度时,就可以保存一个”快照”,在git中,这个快照被称为 commit.若误删文件,或改乱文件就可以,从最近的一个 commit 恢复 查看git的历史记录 1git log git log 可以显示从最近到最远的提交日志,可加参数 –pretty=oneline 回退到上一个版本 在 git 中,用 HEAD 表示当前版本,上一个版本就是 HEAND^,上上个就是 HEAD^^,如果往上100个版本写100个^会数不过来,直接写成 Head~100回到上一个版本(过去的版本): 1git reset --hard HEAD^ 去到下一个版本(未来的某一个版本)指定回到未来的某个版本: 1git reset --hard 1094a 1094a为版本号 当找不到未来版本的版本号时,可以使用 git reflog 记录每一次的命令 git 的版本回退速度非常快,因为git在内部有个指向当前版本的HEAD指针,当你回退版本的时候,git仅仅是把 HEAD 指向 上一个版本]]></content>
      <categories>
        <category>git相关</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的基本使用]]></title>
    <url>%2F2019%2F06%2F13%2Fgit%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是git? git是一个分布式版本控制系统 简单概要 git 与 svn 区别 svn 是集中式版本控制系统,而git是分布式的 git把内容按元数据方式存储,而svn把内容按文件存储 svn 是需要联网的,git不用依赖网络做任何事情 git 上每一个人都是一个版本库,对分支和合并有更好的支持 什么是版本库? 版本库,即为仓库.就是 .git 文件夹 这个目录下的文件都会被git管理起来 git的基本使用 创建版本库(本地仓库) 1git init 查看文件状态 1git status 提交所有改动到暂存区 1git add . 或 git add -A 提交到版本库,即把暂存区所有内容提交到当前分支 1git commit -m "init my project" 每次提交到版本库时都会要求添加备注信息 -m 与远程仓库创建连接 1git remote add orgin "github上的仓库地址" 远程库的名字就是origin,这是Git默认的叫法，也可以改成别的 将本地仓库内容推送到远程仓库 1git push -u orgin master 若时新建的远程仓库为空,加上 -u 参数,git不但会把本地的master分支内容推送到远程新的master分支,还会把本地的master分支和远程的master分支关联起来 以后就只需执行以下代码就可以将本地master分支的最新修改推送的Github 1git push orgin master 从远程仓库克隆 1git clone "远程仓库地址"]]></content>
      <categories>
        <category>git相关</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS之清除浮动]]></title>
    <url>%2F2019%2F06%2F12%2FCSS%E4%B9%8B%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[浮动导致的问题 若父级元素没有设置高度,内部元素都是浮动元素时,会导致父元素坍塌 清除浮动元素方法 父级div定义伪类:after和zoomhtml: 123&lt;div class="parent"&gt; &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt; css: 123456789.parent:after&#123; display:block; clear:both; content:''&#125;.parent&#123; zoom:1 //zoom是IE浏览器专有特性,可以设置对象的缩放比例,可用来清除浮动,和清除margin重叠&#125; 原理:添加一个伪元素,利用 css 的 clear:both 清除浮动,让父元素自动获得高度优点:浏览器支持好缺点:代码多,需要和 zoom 一起使用才能让主流浏览器支持 在结尾处添加空div标签html: 1234&lt;div class="parent"&gt; &lt;div class="son"&gt;&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt; css: 123.clear&#123; clear:both&#125; 原理:添加一个空div,利用css的clear:both清除浮动,让父级div能自动获取高度优点:代码少,浏览器支持好缺点:如果页面浮动布局多,就会增加很多 空div 父级div定义height,指定高度 原理:手动定义height,解决父级div无法自动获取高度的问题优点:代码少,简单缺点:只适用高度固定的布局 触发BFC 父级div定义 overflow 设置父级元素 overflow:hidden 原理:必须定义width,不能定义 height,触发 BFC优点:简单,浏览器支持好缺点:不能和position配合使用,因为超出的尺寸会被隐藏 设置父级元素 overfolw:auto 原理:必须定义width,不能定义 height,触发 BFC优点:简单,浏览器支持好缺点:内部高度超过父级div时,会出现滚动条]]></content>
      <categories>
        <category>css相关</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是BFC?]]></title>
    <url>%2F2019%2F06%2F12%2F%E4%BB%80%E4%B9%88%E6%98%AFBFC%2F</url>
    <content type="text"><![CDATA[什么是BFC BFC: 块级格式化上下文 它决定元素如何对其内容进行定位,以及和其他元素的相互关系 若一个元素符合了成为 BFC 的条件,该元素内部的元素布局和定位与外部元素互不影响,是一个独立的容器 在 BFC 中,盒子从顶端开始垂直的一个接一个排列 在同一个 BFC 下,两个相邻的块级盒子的垂直外边距会重叠 怎么触发BFC 根元素 浮动元素–float 除 none 外的值 overflow 除 visible 外的值(hidden,auto,scroll) display 为 inline-blocks,table-cells,table-captions position 为绝对定位( absoulte,fixed ) 计算BFC高度时,浮动元素参与计算 BFC 有什么作用 清除内部浮动 当父元素没有设置高度时,子元素都是浮动元素时,此时父元素高度会发生坍塌,即子元素无法撑起父元素的高度.此时触发BFC可解决此问题 清除浮动方法 不被浮动元素遮盖 div浮动兄弟遮盖问题: 由于左侧块级元素发生浮动,所以和右侧不在同一层内,所以产生遮盖 解决方法: 给右侧块级设置 overflow:hidden 触发 BFC 解决元素 margin 坍塌问题 margin塌陷问题: 在标准文档流中,块级标签中竖直方向上margin,会以较大的为准,就出现margin坍塌问题 可以使用 overflow:hidden 触发 BFC 解决 相关文章 BFC原理剖析 CSS篇——BFC与margin BFC及其作用]]></content>
      <categories>
        <category>css相关</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组ES5相关api]]></title>
    <url>%2F2019%2F06%2F12%2FJavaScript%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3api%2F</url>
    <content type="text"><![CDATA[数组检测是否为数组 使用 instanceof 操作符,判断是否为 Array 的一个实例 1arr instanceof Array 使用 Array.isArray( arr ) 1Array.isArray( arr ) //若是数组,返回 true 创建数组 使用 构造函数Array() 使用构造函数实例化数组.传入一个参数时,代表的是定义数组长度;传入多个参数时,代表的是初始化数组 123var arr = new Array()var arr2 = new Array(3) //创建一个数组长度为三的数组var arr3 = new Array(1,2,3) //创建一个 [1,2,3] 的数组 字面量形式创建 数组转换方法 调用数组的 toString(),valueOf()和toLocaleString()方法 toString() 返回的是一个字符串.数组中每个值得字符串形式,拼接而成的一个以逗号分隔的字符串 1['a','b','c'].toString() //"a,b,c" valueOf() 返回的是数组本身 1['a','b','c'].valueOf() //['a','b','c'] 和toLocaleString 返回结果基本和 toString() 一致 join() 只接受一个参数,返回一个包含所有数组项的字符串 在默认情况下调用toString(),toLocaleString(),valueOf()都会以逗号分隔的字符串的形式返回而我们可以使用,join()设置不同的分隔字符串 123var arr = ['a','b','c'];arr.join(',') // "a,b,c" 同toString()返回结果一样arr.join('|') //"a|b|c" 数组栈方法 使用pop(),push()可以实现栈后进先出的行为.pop()从数组末尾移除最后一项,push()从末尾添加元素,可接收任意数量的参数 push()返回的是数组修改后的长度 pop()返回的数组移除的项 12345var arr = ['a','b','c'];arr.push('d'); //添加一项var i = colors.pop() //取得最后一项console.log(i); //"black" 数组队列方法 队列,就是先进先出.结合使用 shift()和push()可以实现 简单介绍一下 shift()和unshift(): shift() shift() 是移除数组中第一个项,返回的是移除的项 unshift() unshift() 是向数组中添加任意向到头部,返回的是新数组的长度 123var arr = ['a','b','c'];arr.push('d'); //向末尾添加一项arr.shfit(); //移除数组第一项 ,返回的是数组长度 重排序方法 数组中有两个重排序方法:reverse()和sort() reverse():反转数组,反转数组项的顺序sort():默认情况是按升序排列数组项,返回的是排序后的数组 sort()排序原理:sort()方法会调用每一个数组项的toString()转型方法,然后比较得到的字符串,按照字符的Unicode编码排序 123var values = [0,1,5,10,15]values.sort()console.log(values) //0,1,10,15,5 sort()接受的参数是一个函数,可传递一个比较函数,对数组进行升序和降序的操作 123456var arr = [1,3,9,4,10,25]arr.sort(function(param1,param2)&#123; return param2-param1; //降序,若想反转数组,使用 reverse() 更快&#125;)cosole.log(arr) //[25, 10, 9, 4, 3, 1] 关于compare(a,b)的两个参数 默认情况下,若是 a-b &gt; 0 则 a后b前,a-b &lt; 0 则 a前b后;若是 b-a &gt; 0 则 a后b前,b-a &lt; 0 则是 a前b后 操作方法 concat(),slice(),splice() concat() 原理:concat()方法会创建一个当前数组的副本,然后将接受到参数添加到这个副本的末尾,最后返回这个副本,不改变原数组 复制数组:当不给concat()传递参数时,它只是复制当前数组并返回副本 当传递的时一个或多个数组时,则该方法会将这些数组中的每一项都添加到副本数组中;若不是数组则,添加到副本数组末尾 123var arr = ['a','b','c']var arr2 = arr.concat('d,'['c','b','a'])console.log(arr2)//['a','b','c','d','c','b','a'] slice() 基于当前数组的一个或多个项创建一个新数组,相当于截取数组片段,返回的是新数组,不会影响原数组.slice()方法可以接受一个或两个参数,即要返回项的起始和结束位置,返回的新数组包含起始位置和结束位置之间的项(不包括结束项) 123var arr = ['a','b','c','d']var arrs1 = arr.slice(1)// 1 代表起始位置 ['b','c'.'d']var arrs2 = arr.slice(2,3) //['c'] 从索引2开始,但不包括索引 3 如果slice()方法的参数中有一个负数,则用数组长度加上该数来确定相应的位置;若结束位置小于起始位置,则返回空数组 splice() 这个算是最强大的数组方法了,可以使用splice(),对数组进行删除,插入,替换;会改变原始数组 删除: 可以删除任意数量的项,需指定2个参数(参数一:要删除的第一项;参数二:要删除的项数]) 插入: 可以向指定位置插入任意数量的项,需提供三个参数:起始位置,0(要删除的项数),要插入的项 替换: 可以向指定位置插入任意数量的项,且同时删除任意数量项,需指定三个参数:起始位置,要删除的项数,要插入的任意数量的项;插入的项数不必与删除的项数相等 小结:splice(起始位置,删除的项数,更新内容), 若删除项为 0 时,直接插入内容;splice()始终返回一个数组,该数组返回从原始数组中返回的项(如果没有删除任何一个项,则返回一个空数组) 1234567891011121314//删除var colors = ["red","green","blue"]var removed = colors.splice(0,1); //删除第一项console.log(colors) //["green","blue"] 改变了原始数组console.log(removed) //["red"] //返回的数组//插入removed = colors.splice(1,0,"yellow","orange") //从位置1开始插入两项consloe.log(colors) //["green","yellow","orange","blue"] //注意此时的 "blue" 的位置//插入并且删除,即替换removed = colors.splice(1,1,"red","purple");console.log(colors) //["green","red","purple","orange","blue"],删除了 yellowconsole.log(removed) //yellow 返回的数组中只包含一项 位置方法indexOf() 接受两个参数:要查找的项和表示查找起点位置的索引(可选的),从数组的开头(索引为0)开始向后查找 找到相关项则返回数组中的位置,若没有找到相关项的情况下返回 -1 lastIndexOf() 接受两个参数:要查找的项和表示查找起点位置的索引(可选的),从数组的末尾开始向前查找 同上,indexOf()的返回结果 迭代方法 ES5中定义了5个迭带方法,每个方法都接受两个参数:要在每一项运行的函数和运行该函数的作用域(可选)—影响this指向而在传入的函数,可接受三个参数:数组项的值,该项在数组中的位置,数组对象本身;后面两个非必选不会修改包含的值 every() 对数组的每一项运行给定函数,若函数对每一项都返回true,则返回true,否则返回false some() 对数组中的每一项运行给定函数,如果该函数对任一项返回true,则返回true;只要有一项返回true,就停止迭代 some()和every()有相似之处,都用于查询数组中的项是否满足某个条件 123456789101112//every()var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item,index,array)&#123; return (item &gt; 2)&#125;)console.log(everyResult) //false//some()var someResult = numbers.some(function(item,index,array)&#123; return (item &gt; 2)&#125;)console.log(someResult) //true filter() 对数组中的每一项运行给定函数,返回该函数会返回true的项组成的数组.返回false则过滤掉 12345var nums = [1,2,3,4,5,4,3,2,1]var filterRes = nums.filter(function(item,index,array)&#123; return (item &gt; 2);&#125;)console.log(filterRes) //[3,4,5,4,3] 可以使用filter()查询符合某些条件的所有数组项 forEach() 对数组中的每一项运行给定的函数,这个方法没有返回值;本质上与使用for循环迭代数组一样 1234var nums = [1,2,3,4,5,4,3,2,1]nums.forEach(function(item,index,,array)&#123;&#125;) map() 对数组中的每一项运行给定函数,返回每次函数调用的结果组成数组;返回一个数组 12345var numbers = [1,2,3,4,5,4,3,2,1]var mapRes = numbers.map(function(item,index,array)&#123; return item*2&#125;)console.log(mapsRes) //[2,4,6,8,10,8,6,4,2] 小结:map返回一个数组,此数组是对数组项执行传入函数后的结果 归并数组reduce()和reduceRight() 这两个方法都会迭代数组的所有项,然后构建一个最终的返回值;reduce()从第一项开始,reduceRight()最后一项开始 123456var values = [1,2,3,4,5]var sum = values.reduce(function(prev,cur,index,array)&#123; return prev + cur; //第一次执行函数 prev 是 1,cur 是 2,第二次执行函数 prev 是 3, cur是 3;依次迭代每一项&#125;)console.log(sum) //15 传入函数的参数分别为: prev表示前一个值,cur表示当前值,index表示项的索引,array表示数组对象 参考书籍JavaScript高级程序设计]]></content>
      <categories>
        <category>javascript相关</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript值传递问题]]></title>
    <url>%2F2019%2F06%2F12%2Fjavascript%E5%80%BC%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[值类型与引用类型 值类型: null,undefined,boolean,number,string 引用类型: Array,Function,Number,Object 等值类型与引用类型的区别 值类型是按值访问的,变量保存的变量值,数据保存在栈结构当中 引用类型是按引用访问的,引用类型的存储需要栈区和堆区,变量保存的是引用地址,栈区内存保存的是引用地址,而堆中保存的保存的实际对象 基本类型在赋值时是拷贝值,引用类型在赋值时是拷贝地址 函数传递是按值传递的 在参数传递基本类型的时候,被传递的值会被复制给一个局部变量(即命名参数) 基本类型的值传递 12345678function addTen( num )&#123; num += 10; return num;&#125;var count = 20;var result = addTen( count );console.log( count ); //20console.log( result ); //30 小结: 基本类型的是值传递,函数内部对变量count的修改不会影响函数外部变量count. 参数 num 和 变量coun 互不认识,只是具有共同的值 引用类型的值传递一(修改属性) 123456function setName( obj )&#123; obj.name = "Zheng";&#125;var person = new Object();setName( person )console.log( person.name ) // "Zheng" 小结:从上述看,函数内部的局部变量变化确实是反映在函数外部了.因为此时,函数传递的是内存地址,所以函数内部的局部变量,即参数 obj 和 person 所引用的是同一个对象 ,此时修改 obj 会反映到函数外部.(修改对象属性会反映到外部) 来看看这个例子吧 引用类型的值传递二(修改对象的引用) 12345678function setName( obj )&#123; obj.name = "Zheng"; obj = new Object(); //此时将一个新对象赋值给obj,操作的函数内部的局部对象,函数执行完毕就销毁 obj.name = "Yang"&#125;var person = new Object();setName( person );console.log( person.name ) // "Zheng" 小结: “obj = new Object()” 是对对象进行赋值,后续引用的也都是这个对象,跟传入的 person 没有关系,在函数执行完毕这个局部对象会被销毁 如果对传入对象本身赋值，则属于局部对象赋值，这个时候和传入的参数已经没有关系了 总结 函数参数传递是按值传递 函数内部对 变量的修改是 不会反映到函数外部的 当函数内部,对传入对象添加属性时,此时 反映到函数外部,而对 传入对象进行赋值操作时,则不会反映到外部,即函数对属性的操作是保留的 基本类型的值传递是,传递值本身(直接把值存在栈中).引用类型的值传递是,传递引用地址(栈中存储的是 引用地址,堆中存储复杂对象) 为甚么函数参数传递是值传递的方式呢? 因为在传递参数时,被传递的值会被赋值给一个局部变量,基本类型相当于在栈中进行值的拷贝,引用类型拷贝的是地址]]></content>
      <categories>
        <category>javascript相关</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js基本指令]]></title>
    <url>%2F2019%2F06%2F09%2Fvue%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Vue.jsVue.js基础 1.x 版本中的filterBy指令，在2.x中已经被废除： filterBy - 指令 12345678910111213141516&lt;tr v-for="item in list | filterBy searchName in 'name'"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在2.x版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 1234&lt;hr&gt; 输入筛选名称：&lt;input type="text" v-model="searchName"&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的methods 方法，同时，把过滤条件searchName传递进去： 1234567891011121314151617181920&lt;tbody&gt; &lt;tr v-for="item in search(searchName)"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href="#" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 12345678910search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML元素： 12&lt;td&gt;&#123;&#123;item.ctime | dataFormat('yyyy-mm-dd')&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = "") &#123; // 在参数列表中 通过 pattern="" 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用ES6中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个全局过滤器Vue.filter('dataFormat', function (input, pattern = '') &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, '0'); var d = dt.getDate().toString().padStart(2, '0'); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, '0'); var mm = dt.getMinutes().toString().padStart(2, '0'); var ss = dt.getSeconds().toString().padStart(2, '0'); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x中自定义键盘修饰符【了解即可】12Vue.directive('on').keyCodes.f2 = 113; 2.x中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 12&lt;input type="text" v-model="name" @keyup.f2="add"&gt; 自定义指令 自定义全局和局部的 自定义指令： 123456789101112131415161718192021222324252627282930313233343536// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive('focus', &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, 'font-weight': function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 12&lt;input type="text" v-model="searchName" v-focus v-color="'red'" v-font-weight="900"&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective('red-color', &#123; bind: function () &#123; this.el.style.color = 'red'; &#125;&#125;); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; vue-resource 实现 get, post, jsonp请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的URL请求资源地址： get请求地址： http://vue.studyit.io/api/getlunbo post请求地址：http://vue.studyit.io/api/post jsonp请求地址：http://vue.studyit.io/api/jsonp JSONP的实现原理 由于浏览器的安全性限制，不允许AJAX访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称作JSONP（注意：根据JSONP的实现原理，知晓，JSONP只支持Get请求）； 具体实现过程： 先在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当作Script脚本去解析执行，这样就能够拿到JSONP的数据了； 带大家通过 Node.js ，来手动实现一个JSONP的请求例子；1234567891011121314151617181920212223242526272829303132333435const http = require('http');// 导入解析 URL 地址的核心模块const urlModule = require('url');const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on('request', (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === '/getjsonp') &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: 'zs', age: 22, gender: '男', hobby: ['吃饭', '睡觉', '运动'] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end('404'); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log('server running at http://127.0.0.1:3000');&#125;); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送get请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get('http://127.0.0.1:8899/api/getlunbo').then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送post请求： 12345678910postInfo() &#123; var url = 'http://127.0.0.1:8899/api/post'; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: 'zs' &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送JSONP请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = 'http://127.0.0.1:8899/api/jsonp'; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; Vue中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML结构： 1234567&lt;div id="app"&gt; &lt;input type="button" value="动起来" @click="myAnimate"&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name="fade"&gt; &lt;div v-show="isshow"&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例： 123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;); 定义两组类样式： 12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库： 1&lt;link rel="stylesheet" type="text/css" href="./lib/animate.css"&gt; 定义 transition 及属性： 123456&lt;transition enter-active-class="fadeInRight" leave-active-class="fadeOutRight" :duration="&#123; enter: 500, leave: 800 &#125;"&gt; &lt;div class="animated" v-show="isshow"&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数： 123456789&lt;div id="app"&gt; &lt;input type="button" value="切换动画" @click="isshow = !isshow"&gt; &lt;transition @before-enter="beforeEnter" @enter="enter" @after-enter="afterEnter"&gt; &lt;div v-if="isshow" class="show"&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法： 12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = 'translateX(500px)'; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = 'translateX(0px)'; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125; 定义动画过渡时长和样式： 123.show&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式： 123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt; 定义DOM结构，其中，需要使用 transition-group 组件把v-for循环的列表包裹起来： 1234567&lt;div id="app"&gt; &lt;input type="text" v-model="txt" @keyup.enter="add"&gt; &lt;transition-group tag="ul" name="list"&gt; &lt;li v-for="(item, i) in list" :key="i"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM中的结构： 1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; txt: '', list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = ''; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和：123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器]]></content>
      <categories>
        <category>vue相关</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery选择器]]></title>
    <url>%2F2019%2F06%2F08%2Fjquery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.基本选择器基本选择器是Jquery中最常用的选择器 id选择器: $(“#id”) 选择id值为 element 的元素,id值在文档中不能重复,所以的到的是唯一的元素 元素选择器: $(“div”) 选择所有的div标签,返回 div 元素数组 类选择器: $(“.class”) 选择使用 class 类的所有元素 $(“*”) 选中文档中的所有元素 2.层叠选择器如果想通过 DOM 元素之间的 层次关系来获取特定元素,如:后代元素,子元素,相邻元素,兄弟元素等.则需要使用层次选择器 后代选择器: $(“form input”) 选择所有 form 元素中的input元素,包含子元素 儿子选择器: $(“form &gt; input”) 选择所有的form元素中的 input 元素,只包含子元素,不包含子元素的子元素 相邻元素选择器: $(“label + input”) 选择label元素的下一个input元素节点 兄弟选择器: $(“#perv ~ div”) 选择id为 prev 的标签元素的所有的属于同一个父元素的div标签 3.过滤选择器可以通过特定的规则筛选出所需的DOM元素,一般以 “:” 开头按照不同的过滤规则,可分为:内容过滤,可见性过滤,属性过滤,子元素过滤,表单对象属性过滤选择器 3.1基础过滤选择器 $(“tr:first”):选择所有 tr 元素的第一个 (“tr:last”):选择所有tr元素的最后一个 $(“tr:even”):选择索引号为偶数的tr元素 索引从 0 开始 $(“tr:odd”) 选择所有的 tr 元素的 索引号为奇数 3.2内容过滤器 $(“div:contains(‘jn’)”):选择所有div 中含有 jn 文本的元素 $(“td:empty”)选择所有为空的 td 元素 $(“div:has(p)”)选择所有含有 p 标签的div 元素 $(“td:parent”)选择所有以td为父节点的元素数组 3.3可视化过滤器 $(“div:hidden”)选择所有的被hidden的div元素 $(“div:visible”)选择所有的可视化的div元素 3.4属性选择过滤器 $(“div[id]”) 选择所有含 id 属性的div元素 $(“input[name=’news’]”)选择所的name 属性等于 news 的 input 元素 $(“input[name^=’news’]”)选择所有的name属性以’news’开头的input元素 $(“input[name$=’news’]”)选择所有的name属性以news结尾的 input 元素 $(“input[name*=’news’]”)选择包含’news’的input元素 3.5子元素过滤器 $(“ul li:nth-child(n)”)匹配其父元素下的第 n 个元素 odd奇数 even偶数 $(“div span:first-child”)返回所有的div元素的第一个子节点的数组 $(“div span:last-child”)返回所有的div元素的最后一个节点]]></content>
      <categories>
        <category>jquery相关</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
</search>
